import getResolvedPaths from '#/configs/getResolvedPaths';
import getSchemaGeneratorOption from '#/configs/getSchemaGeneratorOption';
import * as env from '#/modules/__tests__/env';
import NozzleContext from '#/workers/NozzleContext';
import NozzleEmitter from '#/workers/NozzleEmitter';
import { CE_WORKER_ACTION } from '#/workers/interfaces/CE_WORKER_ACTION';
import type { TPickMasterToWorkerMessage } from '#/workers/interfaces/TMasterToWorkerMessage';
import fastCopy from 'fast-copy';
import path from 'path';
import { createGenerator } from 'ts-json-schema-generator';
import * as tsm from 'ts-morph';
import {
  afterEach,
  beforeAll,
  beforeEach,
  describe,
  expect,
  it,
  vitest,
  type MockInstance,
} from 'vitest';

const originPath = process.cwd();
process.env.USE_INIT_CWD = 'true';
process.env.INIT_CWD = path.join(originPath, 'examples');
const ctx = new NozzleContext();
const data: {
  exit: MockInstance<any, any> | MockInstance<any, never> | undefined;
  send: MockInstance<any, any> | undefined;
} = { exit: undefined, send: undefined };

beforeAll(async () => {
  ctx.project = new tsm.Project({
    tsConfigFilePath: path.join(originPath, 'examples', 'tsconfig.json'),
  });
  ctx.option = {
    ...env.addCmdOption,
    ...getResolvedPaths({
      project: path.join(originPath, 'examples', 'tsconfig.json'),
      output: path.join(originPath, 'examples'),
    }),
    generatorOptionObject: await getSchemaGeneratorOption({
      discriminator: 'add-schema',
      project: path.join(originPath, 'examples', 'tsconfig.json'),
      generatorOption: undefined,
      skipError: env.addCmdOption.skipError,
    }),
  };
  ctx.generatorOption = ctx.option.generatorOptionObject;
  ctx.generator = createGenerator({
    ...ctx.option.generatorOptionObject,
    type: '*',
  });
});

beforeEach(async () => {
  process.env.INIT_CWD = path.join(originPath, 'examples');
  ctx.option = {
    ...env.addCmdOption,
    ...getResolvedPaths({
      project: path.join(originPath, 'examples', 'tsconfig.json'),
      output: path.join(originPath, 'examples'),
    }),
    generatorOptionObject: await getSchemaGeneratorOption({
      discriminator: 'add-schema',
      project: path.join(originPath, 'examples', 'tsconfig.json'),
      generatorOption: undefined,
      skipError: env.addCmdOption.skipError,
    }),
  };
  ctx.generatorOption = ctx.option.generatorOptionObject;
  ctx.generator = createGenerator({
    ...ctx.option.generatorOptionObject,
    type: '*',
  });

  data.exit = vitest.spyOn(process, 'exit').mockImplementationOnce((_code?: number | undefined) => {
    throw new Error('Exit triggered');
  });

  data.send = vitest.spyOn(process, 'send').mockImplementationOnce((_data: unknown) => {
    return true;
  });
});

afterEach(() => {
  if (data.exit != null) {
    data.exit.mockRestore();
  }

  if (data.send != null) {
    data.send.mockRestore();
  }
});

afterEach(() => {
  vitest.clearAllMocks();
});

describe('WorkEmitter - project', () => {
  it('pass - option load emit', async () => {
    const w = new NozzleEmitter({ context: ctx });

    w.emit(CE_WORKER_ACTION.OPTION_LOAD, {
      option: ctx.option,
    } satisfies TPickMasterToWorkerMessage<typeof CE_WORKER_ACTION.OPTION_LOAD>['data']);
  });

  it('pass - project emit', async () => {
    const w = new NozzleEmitter({ context: ctx });
    w.emit(CE_WORKER_ACTION.PROJECT_LOAD);
  });

  it('fail', async () => {
    try {
      const w = new NozzleEmitter({ context: ctx });
      ctx.option.project = '';

      await w.loadProject();
    } catch (caught) {
      expect(caught).toBeDefined();
    }
  });

  it('fail - 2', async () => {
    try {
      const w = new NozzleEmitter();
      ctx.option.project = '';

      w.emit(CE_WORKER_ACTION.PROJECT_LOAD);
    } catch (caught) {
      expect(caught).toBeDefined();
    }
  });

  it('fail - 3', async () => {
    try {
      const w = new NozzleEmitter();
      await w.loadProject();
    } catch (caught) {
      expect(caught).toBeDefined();
    }
  });

  it('working', () => {
    const w = new NozzleEmitter();
    w.working({ command: CE_WORKER_ACTION.NOOP });
  });

  it('diagonostic', async () => {
    const w = new NozzleEmitter({ context: ctx });
    await w.diagonostic();
  });

  describe('diagonostic - exception', () => {
    afterEach(() => {
      const sourceFile = ctx.project.getSourceFile('diagonostic_fail.ts');

      if (sourceFile != null) {
        ctx.project.removeSourceFile(sourceFile);
      }

      ctx.option.skipError = true;
    });

    it('diagonostic - skipError false', async () => {
      try {
        const nctx = new NozzleContext();
        nctx.project = ctx.project;
        nctx.generatorOption = fastCopy(ctx.generatorOption);
        nctx.option = fastCopy(ctx.option);
        nctx.generator = createGenerator(nctx.generatorOption);

        nctx.option.skipError = false;

        const w = new NozzleEmitter({ context: nctx });
        nctx.project.createSourceFile('diagonostic_fail.ts', 'const a = "1"; a = 3', {
          overwrite: true,
        });

        w.emit(CE_WORKER_ACTION.PROJECT_DIAGONOSTIC);
      } catch (caught) {
        expect(caught).toBeDefined();
      }
    });
  });
});
